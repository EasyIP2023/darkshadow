require 'darkshadow/reap/command_names'
require 'darkshadow/reap/content'
require 'optparse'

module Generate
  class Options
    def self.parse(args)
      options = {}
      parser = OptionParser.new do |opt|
        opt.banner = "Usage: #{DARK_SHADOW} #{GENERATE.colorize(:light_yellow)} [options]\nExample: #{DARK_SHADOW} #{GENERATE.colorize(:light_yellow)} -r buffer_overflow"
        opt.separator ''
        opt.separator 'Options:'
        opt.on('-r', '--remote-exploit <filename>', String, 'Generate a remote exploit file') do |file|
          options[:filename] = file
          # Return String from get_remote_content
          set_string(get_remote_content)
        end

        opt.on('-p', '--payload <filename>', String, 'Generate a payload file') do |file|
          options[:filename] = file
          # Return String from get_payload_content
          set_string(get_payload_content)
        end

        opt.on('-g', '--gdb <filename>', String, 'Generate a ruby gdb usage file') do |file|
          options[:filename] = file
          # Return String from get_payload_content
          set_string(get_gdb)
        end

        opt.on_tail('-h', '--help', 'Show this message') do
          $stdout.puts opt
          exit
        end
      end

      parser.parse!(args)

      raise OptionParser::MissingArgument, "No options set, try #{DARK_SHADOW} #{GENERATE.colorize(:light_yellow)} -h for usage" if options.empty?

      options
    end

    def self.set_string(string)
      @string = string
    end

    def self.get_string
      @string
    end
  end

  class Driver
    def initialize
      @opts = Options.parse(ARGV)
    rescue OptionParser::ParseError => e
      warn "[x] #{e.message}"
      exit
    end

    def run
      File.open("#{@opts[:filename]}.rb", 'w+') { |f| f.write(Options.get_string) }
    end
  end
end

@driver = Generate::Driver.new
begin
  @driver.run
rescue ::StandardError => e
  warn "[x] #{e.class}: #{e.message}"
end
