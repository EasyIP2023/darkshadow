require 'darkshadow/reap/command_names'
require 'optparse'

module PatternCreate
  class Options
    def self.parse(args)
      options = {}
      parser = OptionParser.new do |opt|
        opt.banner = "Usage: #{DARK_SHADOW} #{PATTERN_CREATE.colorize(:light_yellow)} [options]\nExample: #{DARK_SHADOW} #{PATTERN_CREATE.colorize(:light_yellow)} -l 50 -s ABC,def,123\nAd1Ad2Ad3Ae1Ae2Ae3Af1Af2Af3Bd1Bd2Bd3Be1Be2Be3Bf1Bf"
        opt.separator ''
        opt.separator 'Options:'
        opt.on('-l', '--length <length>', Integer, 'The length of the pattern') do |len|
          options[:length] = len
        end

        opt.on('-s', '--sets <ABC,def,123>', Array, 'Custom Pattern Sets') do |sets|
          options[:sets] = sets
        end

        opt.on_tail('-h', '--help', 'Show this message') do
          $stdout.puts opt
          exit
        end
      end

      parser.parse!(args)

      if options.empty?
        raise OptionParser::MissingArgument, "No options set, try #{DARK_SHADOW} #{PATTERN_CREATE.colorize(:light_yellow)} -h for usage"
      elsif options[:length].nil? && options[:sets]
        raise OptionParser::MissingArgument, '-l <length> is required'
      end

      options[:sets] = nil unless options[:sets]

      options
    end
  end

  class Driver
    def initialize
      @opts = Options.parse(ARGV)
    rescue OptionParser::ParseError => e
      warn "[x] #{e.message}"
      exit
    end

    def run
      require 'rex'
      require 'rex/text'

      puts Rex::Text.pattern_create(@opts[:length], @opts[:sets])
    end
  end
end

driver = PatternCreate::Driver.new
begin
  driver.run
rescue ::StandardError => e
  warn "[x] #{e.class}: #{e.message}"
end
